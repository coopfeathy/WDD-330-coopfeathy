<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="These are my notes for this week's WDD 330 Assignments.">
    <title>WDD 330 &bull; Notes</title>
    <link rel="stylesheet" href="../css/normalize.css">
    <link rel="stylesheet" href="../css/small.css">
    <link rel="stylesheet" href="../css/medium.css">
</head>
<body>
    <header>
        <h1>WDD 330</h1>
    </header>    
    <main>
        <h2>Week 10 &bull; Notes</h2>
        <hr>
        <p>&bull; This is called form validation. When you enter data, the browser and/or the web server will check to see that the data is in the correct format and within the constraints set by the application. Validation done in the browser is called client-side validation, while validation done on the server is called server-side validation.</p>
        <p>&bull; Built-in form validation uses HTML5 form validation features, which we've discussed in many places throughout this module. This validation generally doesn't require much JavaScript. Built-in form validation has better performance than JavaScript, but it is not as customizable as JavaScript validation.</p>
        <p>&bull; JavaScript validation is coded using JavaScript. This validation is completely customizable, but you need to create it all (or use a library).</p>
        <p>&bull; Required: Specifies whether a form field needs to be filled in before the form can be submitted.</p>
        <p>&bull; Minlength and maxlength: Specifies the minimum and maximum length of textual data (strings).</p>
        <p>&bull; Min and max: Specifies the minimum and maximum values of numerical input types.</p>
        <p>&bull; Type: Specifies whether the data needs to be a number, an email address, or some other specific preset type.</p>
        <p>&bull; Pattern: Specifies a regular expression that defines a pattern the entered data needs to follow.</p>
        <p>&bull; The simplest HTML5 validation feature is the required attribute. To make an input mandatory, add this attribute to the element. When this attribute is set, the element matches the :required UI pseudo-class and the form won't submit, displaying an error message on submission when the input is empty. While empty, the input will also be considered invalid, matching the :invalid UI pseudo-class.</p>
        <p>&bull; Another useful validation feature is the pattern attribute, which expects a Regular Expression as its value. A regular expression (regex) is a pattern that can be used to match character combinations in text strings, so regexps are ideal for form validation and serve a variety of other uses in JavaScript.</p>
        <p>&bull; You can constrain the character length of all text fields created by input or textarea by using the minlength and maxlength attributes. A field is invalid if it has a value and that value has fewer characters than the minlength value or more than the maxlength value.</p>
        <p>&bull; You must use JavaScript if you want to take control over the look and feel of native error messages or to deal with legacy browsers that do not support HTML's built-in form validation. In this section we will look at the different ways to do this.</p>
        <p>&bull; In some cases, such as legacy browser support or custom controls, you won't be able to or won't want to use the Constraint Validation API.You're still able to use JavaScript to validate your form, but you'll just have to write your own.</p>
        <p>&bull; The Fetch API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses. It also provides a global fetch() method that provides an easy, logical way to fetch resources asynchronously across the network.</p>
        <p>&bull; To cause browsers to send a request with credentials included on both same-origin and cross-origin calls, add credentials: 'include' to the init object you pass to the fetch() method.</p>
        <p>&bull; Use fetch() to POST JSON-encoded data.</p>
        <p>&bull; Files can be uploaded using an HTML input type="file" input element, FormData() and fetch().</p>
        <p>&bull; A fetch() promise will reject with a TypeError when a network error is encountered or CORS is misconfigured on the server-side, although this usually means permission issues or similar â€” a 404 does not constitute a network error, for example. An accurate check for a successful fetch() would include checking that the promise resolved, then checking that the Response.ok property has a value of true.</p>
        <p>&bull; Instead of passing a path to the resource you want to request into the fetch() call, you can create a request object using the Request() constructor, and pass that in as a fetch() method argument.</p>
        <p>&bull; Since headers can be sent in requests and received in responses, and have various limitations about what information can and should be mutable, headers' objects have a guard property. This is not exposed to the Web, but it affects which mutation operations are allowed on the headers object.</p>
        <p>&bull; The Request and Response interfaces share the following methods to extract a body. These all return a promise that is eventually resolved with the actual content.</p>
        <p>&bull; Fetch API support can be detected by checking for the existence of Headers, Request, Response or fetch() on the Window or Worker scope.</p>
    </main>
    <footer>
        <p><a href="../index.html">Portfolio</a>
    </footer>
   
</body>
</html>