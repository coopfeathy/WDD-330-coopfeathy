<!DOCTYPE html>
<html lang="en-us">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="These are my notes for this week's WDD 330 Assignments.">
    <title>WDD 330 &bull; Notes</title>
    <link rel="stylesheet" href="../css/normalize.css">
    <link rel="stylesheet" href="../css/small.css">
    <link rel="stylesheet" href="../css/medium.css">
</head>
<body>
    <header>
        <h1>WDD 330</h1>
    </header>    
    <main>
        <h2>Week 7 &bull; Notes</h2>
        <hr>
        <p>&bull; The fact that functions are first-class objects means they can have properties and methods themselves</p>
        <p>&bull; The call() method can be used to set the value of this inside a function to an object that is provided as the first argument</p>
        <p>&bull; There is nothing to stop you adding your own properties to functions in the same way that you can add properties to any object in JavaScript</p>
        <p>&bull; If a function takes some time to compute a return value, we can save the result in a cache property. Then if the same argument is used again later, we can return the value from the cache, rather than having to compute the result again</p>
        <p>&bull; An Immediately Invoked Function Expression - or IIFE - (pronounced 'iffy') is an anonymous function that, as the name suggests, is invoked as soon as it's defined. This is easily achieved by placing parentheses at the end of the function definition (remember we use parentheses to invoke a function). The function also has to be made into an expression, which is done by placing the whole declaration inside parentheses</p>
        <p>&bull; IIFEs are a useful way of performing a task while keeping any variables wrapped up within the scope of the function. This means the global namespace is not polluted with lots of variable names</p>
        <p>&bull; There is no way to remove a variable from a scope once it's been declared. If a variable is only required temporarily, it may cause confusion if it's still available later in the code. Even worse, the name of the variable may clash with another piece of code (an external JavaScript library, for example) resulting in errors. Placing any code that uses the temporary variable inside an IIFE will ensure it's only available while the IIFE is invoked, then it will disappear</p>
        <p>&bull; An IIFE can be used to set up any initialization code that there'll be no need for again. Because the code is only run once, there's no need to create any reusable, named functions, and all the variables will also be temporary. An IIFE will be invoked once, and can set up any variables, objects and event handlers when the page loads</p>
        <p>&bull; An IIFE can be used to enclose a block of code inside its own private scope so it doesn't interfere with any other part of the program. Using IIFEs in this way means code can be added or removed separately</p>
        <p>&bull; The dynamic nature of JavaScript means that a function is able to not only call itself, but define itself, and even redefine itself. This is done by assigning an anonymous function to a variable that has the same name as the function. If the function is also assigned to another variable, this variable will maintain the original function definition and not be rewritten. This is because the original function is assigned to a variable, then within the function, a variable with the same name as the function is assigned to a different function</p>
        <p>&bull; If any properties have previously been set on the function, these will be lost when the function redefines itself</p>
        <p>&bull; A recursive function is one that invokes itself until a certain condition is met. It's a useful tool to use when iterative processes are involved</p>
        <p>&bull; Callbacks are functions passed to other functions as arguments and then invoked inside the function they are passed to</p>
        <p>&bull; Callbacks can be used to facilitate event-driven asynchronous programming</p>
        <p>&bull; JavaScript is a single-threaded environment, which means only one piece of code will ever be processed at a time</p>
        <p>&bull; The increase in the use of asynchronous programming in JavaScript has meant that more and more callbacks are being used. This can result in messy and confusing 'spaghetti code'. This is when more than one callback is used in the same function, resulting in a large number of nested blocks that are difficult to comprehend. Callback hell is the term used to refer to this tangled mess of code</p>
        <p>&bull; A promise represents the future result of an asynchronous operation. Promises don't do anything that can't already be achieved using callbacks, but they help simplify the process, and avoid the convoluted code that can result from using multiple callbacks</p>
        <p>&bull; When a promise is created, it calls an asynchronous operation and is then said to be pending. It remains in this state while the operation is taking place. At this stage, the promise is said to be unsettled. Once the operation has completed, the promise is said to have been settled. A settled promise can result in two different outcomes:</p>
        <p class="indented">&bull; Resolved ― the asynchronous operation was completed successfully.</p>
        <p class="indented">&bull; Rejected ― the asynchronous operation didn't work as expected, wasn't successfully completed or resulted in an error.</p>
        <p>&bull; Both these outcomes will return any relevant data, and you can take the appropriate action based on the outcome of the promise</p>
        <p>&bull; A promise is created using a constructor function. This takes a function called an executor as an argument. The executor initializes the promise and starts the asynchronous operation. It also accepts two functions as arguments: the resolve() function is called if the operation is successful, and the reject() function is called if the operation fails</p>
        <p>&bull; Once a promise has been settled, the then() method can be used to deal with the outcome. This method accepts two arguments. The first is a fulfilment function that's called when the promise is resolved. Any data returned from the resolve() function will be passed along to this function. The second argument is a rejection function that's called if the promise is rejected. Similar to the fulfilment function, the rejection function receives any data returned from the reject() function</p>
        <p>&bull; Promises come into their own when multiple asynchronous tasks are required to be carried out one after the other. If each function that performs an asynchronous operation returns a promise, we can chain the then() methods together to form a sequential piece of code that's easy to read. Each promise will only begin once the previous promise has been settled</p>
        <p>&bull; Async functions were added to the ES2017 specification. These functions are preceded by the async keyword and allow you to write asynchronous code as if it was synchronous. This is achieved by using the await operator before an asynchronous function. This will wrap the return value of the function in a promise that can then be assigned to a variable. The next line of code is not executed until the promise is resolved</p>
        <p>&bull; Callbacks can be used to build more generalized functions. Instead of having lots of specific functions, one function can be written that accepts a callback</p>
        <p>&bull; Functions can accept another function as an argument (a callback), but they can also return a function</p>
        <p>&bull; A closure is formed when the inner function is returned by the outer function, maintaining access to any variables declared inside the enclosing function</p>
        <p>&bull; A closure is formed when a function returns another function that then maintains access to any variables created in the original function's scope</p>
        <p>&bull; Closures not only have access to variables declared in a parent function's scope, they can also change the value of these variables. This allows us to do things like create a counter() function</p>
        <p>&bull; Generators are special functions used to produce iterators that maintain the state of a value. To define a generator function, an asterisk symbol (*) is placed after the function declaration</p>
        <p>&bull; Calling a generator function doesn't actually run any of the code in the function; it returns a Generator object that can be used to create an iterator that implements a next() method that returns a value every time the next() method is called</p>
        <p>&bull; Higher-order functions are functions that accept another function as an argument, or return another function as a result, or both</p>
        <p>&bull; Currying is a process that involves the partial application of functions. A function is said to be curried when not all arguments have been supplied to the function, so it returns another function that retains the arguments already provided, and expects the remaining arguments that were omitted when the original function was called. A final result is only returned once all the expected arguments have eventually been provided. Currying relies on higher-order functions that are able to return partially applied functions. All curried functions are higher-order functions because they return a function, but not all higher-order functions are curried</p>
        <p>&bull; Ajax is a technique that allows web pages to communicate asynchronously with a server, and it dynamically updates web pages without reloading. This enables data to be sent and received in the background, as well as portions of a page to be updated in response to user events, while the rest of the program continues to run</p>
        <p>&bull; The Fetch API provides a global fetch() method that only has one mandatory argument, which is the URL of the resource you wish to fetch</p>
        <p>&bull; The Fetch API introduced the Response interface that deals with the object that's returned when the promise is fulfilled. Response objects have a number of properties and methods that allow us to process the response effectively</p>
        <p>&bull; The redirect() method can be used to redirect to another URL. It creates a new promise that resolves to the response from the redirected URL</p>
        <p>&bull; The text() method takes a stream of text from the response, reads it to completion and then returns a promise that resolves to a USVSting object that can be treated as a string in JavaScript</p>
        <p>&bull; JSON is probably the most common format for AJAX responses. The json() method is used to deal with these by transforming a stream of JSON data into a promise that resolves to a JavaScript object</p>
        <p>&bull; The five most commonly used verbs when dealing with resources on the web are:</p>
        <p class="indented">&bull; GET requests to retrieve resources</p>
        <p class="indented">&bull; POST requests, usually used to create a resource but can actually perform any task</p>
        <p class="indented">&bull; PUT requests to upsert, which means insert a resource or update it entirely</p>
        <p class="indented">&bull; PATCH requests to make partial updates to a resource</p>
        <p class="indented">&bull; DELETE requests to delete a resources.</p>
        <p>&bull; HTTP headers are used to pass on any additional information about a request or response. Typical information contained in headers includes the file-type of the resource, cookie information, authentication information and when the resource was last modified</p>
        <p>&bull; The Fetch API includes the FormData interface, which makes it much easier to submit information in forms using Ajax. A FormData instance is created using a constructor function</p>
        <p>&bull; Ajax is a technique for sending and receiving data asynchronously in the background.</p>
        <p>&bull; The data can be sent in many forms, but it is usually in JSON.</p>
        <p>&bull; Ajax can be used for making partial page updates without having to do a full page reload.</p>
        <p>&bull; Ajax can be used for communicating with external APIs.</p>
        <p>&bull; Ajax requests can be made using the Fetch API.</p>
        <p>&bull; The Response interface allows you to control the response received from a request or to create your own response objects.</p>
        <p>&bull; The Request interface allows you to create a request object that contains information about the request being made, such as the URL and headers.</p>
        <p>&bull; The Headers interface allows you to create HTTP headers that can be added to a request or response object.</p>
        <p>&bull; Requests can retrieve data using a GET request, or send data using a POST request.</p>
        <p>&bull; The FormData interface makes it easier to send data from forms.</p>
    </main>
    <footer>
        <p><a href="../index.html">Portfolio</a>
    </footer>
</body>
</html>